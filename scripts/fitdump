#!/usr/bin/env python

import argparse
import csv
import sys

# Python 2 compat
try:
    BrokenPipeError
except NameError:
    import socket
    BrokenPipeError = socket.error

import fitparse


def format_message(message, options):
    s = message.name
    if options.with_defs:
        s += ' [%s]' % message.type
    s += '\n'

    if message.type == 'data':
        for field_data in message:
            s += ' * %s: %s' % (field_data.name, field_data.value)
            if field_data.units:
                s += ' [%s]' % field_data.units
            s += '\n'
    else:
        print message.tpye
    return s
    
_DEFAULT_RUN_HEADERS = [
    'timestamp', 'altitude [m]', 'cadence [rpm]', 'distance [km]',
    'heart_rate [bpm]', 'position_lat [deg]', 'position_long [deg]',
    'speed [km/h]', 'temperature [C]', 'unknown_39', 'unknown_40',
    'unknown_41', 'unknown_42', 'unknown_53', 'unknown_83', 'unknown_84',
    'unknown_85', 'unknown_87', 'unknown_88']

_DEFAULT_HEADERS = [
    'timestamp', 'heart_rate', 'cadence', 'speed', 'distance',
    'position_lat', 'position_long', 'altitude', 'temperature']

def parse_args(args=None):
    parser = argparse.ArgumentParser(
        description='Dump .FIT files to various formats',
        epilog='python-fitparse version %s' % fitparse.__version__,
    )
    parser.add_argument('-v', '--verbose', action='count', default=0)
    parser.add_argument(
        '-o', '--output', type=argparse.FileType(mode='wb'),
        help='File to output to.',
    )
    parser.add_argument(
        '-t', '--type', choices=('csv', 'excel', 'readable'), default='readable',
        help='File type to output. (DEFAULT: %(default)s)',
    )
    parser.add_argument(
        '-n', '--name', action='append', help='Message name (or number) to filter',
    )
    parser.add_argument(
        'infile', metavar='FITFILE', type=argparse.FileType(mode='rb'),
        help='Input .FIT file (Use - for stdin)',
    )
    parser.add_argument(
        '--ignore-crc', action='store_const', const=True, help='Some devices seem to write invalid crc\'s, ignore these.'
    )

    options = parser.parse_args(args)

    if (options.type != 'readable') and not options.output:
        parser.error('Please specify an output file (-o) or set --type readable')

    options.with_defs = (options.verbose >= 1)
    options.print_messages = (options.type == 'readable')
    options.print_stream = (options.output or sys.stdout)

    if not options.print_messages and (options.verbose >= 1):
        options.print_messages = True
        options.print_stream = sys.stdout

    return options
    
def field_name(record_data):
    #if record_data.units:
    #    return "%s [%s]" % (record_data.name, record_data.units)
    return record_data.name
    
def record_as_dict(record):
    d = {}
    for record_data in record:
        name = field_name(record_data)
        d[name] = record.get_value(name) #record_data.value
    return d
    
def record_as_row(record, headers):
    d = record_as_dict(record)
    row =[]
    for header in headers:
        try:
            row.append(d[header])
        except KeyError:
            pass
    return row

def get_csv_headers(messages):
    headers = set()
    for record in messages:
        for record_data in record:
            headers.add(field_name(record_data))
    return sorted(headers)

def main(args=None):
    options = parse_args(args)

    fitfile = fitparse.FitFile(
        options.infile,
        data_processor=fitparse.StandardUnitsDataProcessor(),
        check_crc = not(options.ignore_crc),
    )
    """
    messages = fitfile.get_messages(
        name=options.name,
        with_definitions=options.with_defs,
    )
    """
    #messages = fitfile.get_messages('record')
    
    #headers = get_csv_headers(messages)
    headers = _DEFAULT_HEADERS
    #with open(options.output, 'wb') as fh:
    writer = csv.writer(options.output)
    writer.writerow(headers)

    messages = fitfile.get_messages('record')
    for n, message in enumerate(messages, 1):
        writer.writerow(record_as_row(message, headers))
        
if __name__ == '__main__':
    try:
        main()
    except BrokenPipeError:
        pass
